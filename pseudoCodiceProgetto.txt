# Blender v2.82 (sub 7) OBJ File: ''
# www.blender.org
o Cubooo_Cube
v 1.000000 1.000000 -1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 1.000000 -1.000000
v -1.0	
v -1.000000 1.000000 1.000000
v -1.000000 -1.000000 1.000000
s off
f 1 5 7 3
f 4 3 7 8
f 8 7 5 6
f 6 2 4 8
f 2 1 3 4
f 6 5 1 2



e15 e57 e73 e 31


//matrice degli spigoli
 prima faccia
 1 2 3 4 5 6 7 8
 1 0 0 0 1 0 0 0
 0 0 0 0 1 0 1 0
 0 0 1 0 0 0 1 0
 1 0 1 0 0 0 0 0
 
 
 list = [ 1 5 7 4]
 
 
 // list contiene i vertici appartenenti alla faccia
 addEdge(list) {
  matrix = [[]
  if(list.size == 1) {
  	return
  } else if (list.size == 2) {
  	creo una nuova riga della matrice con dimensione list.size e valorizzo a 1 gli index corrispondenti a list[0] e list[1]
  	metodo che controlla l'esistenza della nuova riga
  } else {
  	for (int i = 1; i < list.size ; i++) {
  	  creo una nuova riga
  	  int previousIndex = list.get(i-1))
  	  int currentIndex = list.get(i)
  	  set degli 1 nella riga in base a previousIndex e currentIndex
  	  metodo che controlla l'esistenza della nuova riga
  	 aggiungo la nuova riga
  	}
  	creo una nuova riga
  	  int previousIndex = list.get(0))
  	  int currentIndex = list.get(list.size-1)
  	  set degli 1 nella riga in base a previousIndex e currentIndex
  	  metodo che controlla l'esistenza della nuova riga
  	 aggiungo la nuova riga
   }	
  }
  
  // il metodo calcola la matrice degli spigoli M1
  createMatrixM1(listFaces) {
  	for( int i = 0; i < listFaces.size; i++) {
  	  addEdge(listFaces.get(i))
  	}
  
  }
   

//Matrice M2
1 0 1 0 1 0 1 0 -> f1
0 0 1 1 0 0 1 1 -> f2
0 0 0 0 1 1 1 1 -> f3
0 1 0 1 0 1 0 1 -> f4
1 1 1 1 0 0 0 0 -> f5
1 1 0 0 1 1 0 0 -> f6


list[f1,f2,f3,f4,f5,f6]



//SECONDA SOLUZIONE

f1	1 5 7 3 
f2 	4 3 7 8
f3 	8 7 5 6
f4 	6 2 4 8
f5 	2 1 3 4
f6 	6 5 1 2

listFaces[f1,f2,f3,f4,f5,f6] le facce lette dal file obj
tot numero dei vertici totali letto dal file obj

createM2(listFaces,tot) {
  matrix = [[]]
  for(int i = 0; i < listFaces.size; i++) {
   vector[tot]
   currentList = listFaces.get(i)
   for(int j = 0; j < currentList.size; j++) {
    int value = currentList[j]
    vector[value-1] = 1
   }
   matrix.add(vector)
  }
  return matrix

}

//Matrice M2
1 0 1 0 1 0 1 0 -> f1
0 0 1 1 0 0 1 1 -> f2
0 0 0 0 1 1 1 1 -> f3
0 1 0 1 0 1 0 1 -> f4
1 1 1 1 0 0 0 0 -> f5
1 1 0 0 1 1 0 0 -> f6

list[f1,f2,f3,f4,f5,f6]


//METODI PER LA GENERAZIONE DELLA MATRICE M1 A PARTIRE DA LIST(lista contenente le facce)
createM1(list) {
 matrix = [[]]
 for(int i = 0; i < list.size - 1; i++) {
   currentList = list.get(i)
   for(int j = i + 1; j < list.size; j++) {
    nextList = list.get(j)
    sumVector = sumBetweenList(currentList, nextList);
    addEdge(sumVector, matrix)
   } 	
 }

}

//first è una lista e second è una lista
// le due liste devono avere la stessa dimensione
sumBetweenList(first, second){
 if(first.size != second.size) {
  return
 }
 
 int size = first.size
 int index = 0;
 resultSum = [size] // lista vuota di dimensione size
 while(index < size) {
  resultSum[index] = first[index] + second[index]
  index++
 }
 return resultSum
}



addEdge(vectorSum, matrix) {
 int size = vectorSum.size
 
 for( int i = 0; i < size; i++) {
  if(vectorSum[i] != 2 ) {
   vectorSum[i] = 0
  } else {
   vectorSum[i] = 1
  }
 }
 
 matrix.add(vectorSum)

}



// implementazione delle nove funzioni

M1 è la matrice degli spigoli
getMatrixVV(M1) {

 transpose = gianmaria.getTranspose(M1)
 result = gianmaria.getResult(transpose, M1)
 return result

}


M1 è la matrice degli spigoli
getMatrixVE(M1) {
 return gianmaria.getTranspose(M1)
 
}

M2 è la matrice delle facce
getMatrixVF(M2) {
 return gianmaria.getTranspose(M2)
}

M1 è la matrice degli spigoli
getMatrixEV(M1) {
 return M1
}


M1 è la matrice degli spigoli
getMatrixEE(M1) {
 transpose = gianmaria.getTranspose(M1)
 result = gianmaria.getResult(M1, transpose)
 return result
}

M1 è la matrice degli spigoli, M2 è la matrice delle facce
getMatrixEF(M1,M2) {
 transposeM2 = gianmaria.getTranspose(M2)
 result = gianmaria.getResult(M1, transposeM2)
 return result
}

M2 è la matrice delle facce
getMatrixFV(M2) {
 return M2
}


M1 è la matrice degli spigoli, M2 è la matrice delle facce
getMatrixFE(M1,M2) {
 transposeM1 = gianmaria.getTranspose(M1)
 result = gianmaria.getResult(M2, transposeM1)
 return result
}

M2 è la matrice delle facce
getMatrixFF(M2) {
 transpose = gianmaria.getTranspose(M2)
 result = gianmaria.getResult(M2, transpose)
 return result
}




